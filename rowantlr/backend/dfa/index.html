<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="DFA related data structures, backend for regular expressions."><meta name="keywords" content="rust, rustlang, rust-lang, dfa"><title>rowantlr::backend::dfa - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a class="sidebar-logo" href="../../../rowantlr/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.png" alt="logo"></div>
        </a><h2 class="location">Module dfa</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></div><div id="sidebar-vars" data-name="dfa" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../rowantlr/index.html"><img class="rust-logo" src="../../../rust-logo.png" alt="logo"></a><nav class="sub"><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../../index.html">rowantlr</a>::<wbr><a href="../index.html">backend</a>::<wbr><a class="mod" href="#">dfa</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/rowantlr/backend/dfa.rs.html#20-653" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>DFA related data structures, backend for regular expressions.</p>
<ul>
<li>Use <a href="../../ir/lexical/struct.Expr.html#method.build" title="Expr::build"><code>Expr::build</code></a>, <a href="struct.BuildResult.html#method.try_resolve" title="BuildResult::try_resolve"><code>BuildResult::try_resolve</code></a> to build DFAs;</li>
<li>Run a DFA on some input with <a href="struct.Dfa.html#method.run" title="Dfa::run"><code>Dfa::run</code></a> and <a href="struct.Resolved.html#method.run" title="Resolved::run"><code>Resolved::run</code></a>;</li>
<li>Minimise a DFA with <a href="struct.Resolved.html#method.minimise" title="Resolved::minimise"><code>Resolved::minimise</code></a>;</li>
</ul>
<p>Below is an example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">rowantlr::ir::lexical::Expr</span>;
<span class="kw">use</span> <span class="ident">rowantlr::backend::dfa::InvalidInput</span>;
<span class="kw">let</span> <span class="ident">expr</span> <span class="op">=</span> <span class="ident">Expr::concat</span>([
    <span class="ident">Expr::singleton</span>(<span class="string">&#39;a&#39;</span>),
    <span class="ident">Expr::many</span>(<span class="ident">Expr::union</span>([
        <span class="ident">Expr::singleton</span>(<span class="string">&#39;a&#39;</span>),
        <span class="ident">Expr::singleton</span>(<span class="string">&#39;b&#39;</span>),
    ])),
    <span class="ident">Expr::singleton</span>(<span class="string">&#39;b&#39;</span>),
]);
<span class="kw">let</span> <span class="ident">resolved</span> <span class="op">=</span> <span class="ident">expr</span>.<span class="ident">build</span>().<span class="ident">try_resolve</span>().<span class="ident">unwrap</span>();
<span class="comment">// the minimised DFA and the original should behave the same</span>
<span class="kw">for</span> <span class="ident">m</span> <span class="kw">in</span> [<span class="ident">resolved</span>.<span class="ident">clone</span>(), <span class="ident">resolved</span>.<span class="ident">minimise</span>()] {
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(()), <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;aab&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap</span>());
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(()), <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;ab&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap</span>());
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(()), <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;abab&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap</span>());
    <span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;aa&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap</span>());
    <span class="kw">let</span> <span class="ident">InvalidInput</span> { <span class="ident">current_state</span>, <span class="ident">current_input</span>, <span class="ident">remaining_input</span> }
        <span class="op">=</span> <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;baaa&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap_err</span>();
    <span class="macro">assert_eq!</span>(<span class="ident">current_state</span>, <span class="number">0</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">current_input</span>, <span class="string">&#39;b&#39;</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">remaining_input</span>.<span class="ident">as_str</span>(), <span class="string">&quot;aaa&quot;</span>);
}</code></pre></div>
<p>Use <a href="../../ir/lexical/struct.Expr.html#method.build_many" title="Expr::build_many"><code>Expr::build_many</code></a> to build <a href="struct.Dfa.html" title="Dfa"><code>Dfa</code></a> from multiple regular expressions, and use
<a href="struct.BuildResult.html#method.apply_hint" title="BuildResult::apply_hint"><code>BuildResult::apply_hint</code></a> to resolve a conflict (<a href="struct.BuildResult.html#method.apply_hints" title="BuildResult::apply_hints"><code>BuildResult::apply_hints</code></a> can
also be used to resolve conflicts in batch):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">rowantlr::ir::lexical</span>::{<span class="ident">Expr</span>, <span class="ident">PosInfo</span>};
<span class="kw">use</span> <span class="ident">rowantlr::backend::dfa::ResolveError</span>;
<span class="comment">// start with &#39;a&#39;, end with &#39;b&#39;</span>
<span class="kw">let</span> <span class="ident">e1</span> <span class="op">=</span> <span class="ident">Expr::concat</span>([
    <span class="ident">Expr::singleton</span>(<span class="string">&#39;a&#39;</span>),
    <span class="ident">Expr::many</span>(<span class="ident">Expr::any_of</span>(<span class="string">&quot;ab&quot;</span>)),
    <span class="ident">Expr::singleton</span>(<span class="string">&#39;b&#39;</span>),
]);
<span class="comment">// even number of &#39;a&#39;s and &#39;b&#39;s.</span>
<span class="kw">let</span> <span class="ident">e2</span> <span class="op">=</span> <span class="ident">Expr::many</span>(<span class="ident">Expr::union</span>([
    <span class="ident">Expr::from</span>(<span class="string">&quot;aa&quot;</span>),
    <span class="ident">Expr::from</span>(<span class="string">&quot;bb&quot;</span>),
    <span class="ident">Expr::concat</span>([
        <span class="ident">Expr::from</span>(<span class="string">&quot;ab&quot;</span>) <span class="op">|</span> <span class="ident">Expr::from</span>(<span class="string">&quot;ba&quot;</span>),
        <span class="ident">Expr::many</span>(<span class="ident">Expr::from</span>(<span class="string">&quot;aa&quot;</span>) <span class="op">|</span> <span class="ident">Expr::from</span>(<span class="string">&quot;bb&quot;</span>)),
        <span class="ident">Expr::from</span>(<span class="string">&quot;ab&quot;</span>) <span class="op">|</span> <span class="ident">Expr::from</span>(<span class="string">&quot;ba&quot;</span>),
    ]),
]));
<span class="comment">// &#39;e1&#39; and &#39;e2&#39; should intersect.</span>
<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">Expr::build_many</span>([(<span class="kw-2">&amp;</span><span class="ident">e1</span>, <span class="number">0</span>), (<span class="kw-2">&amp;</span><span class="ident">e2</span>, <span class="number">1</span>)]);
<span class="kw">let</span> (<span class="ident">result</span>, <span class="ident">conflicts</span>) <span class="op">=</span> <span class="ident">result</span>.<span class="ident">try_resolve</span>().<span class="ident">expect_err</span>(<span class="string">&quot;conflict expected&quot;</span>);
<span class="comment">// exactly one conflict is detected.</span>
<span class="macro">assert_eq!</span>(<span class="ident">conflicts</span>.<span class="ident">len</span>(), <span class="number">1</span>);
<span class="kw">let</span> <span class="ident">conflict</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">conflicts</span>[<span class="number">0</span>];
<span class="comment">// tag &#39;0&#39; and tag &#39;1&#39; are involved in this conflict.</span>
<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>], <span class="ident">conflict</span>.<span class="ident">conflicting_tags</span>(<span class="kw-2">&amp;</span><span class="ident">result</span>).<span class="ident">copied</span>().<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>());
<span class="comment">// as for the different interpretations for some problematic input ...</span>
<span class="ident">conflict</span>.<span class="ident">interpretations</span>.<span class="ident">iter</span>().<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">ps</span><span class="op">|</span> {
    <span class="comment">// all interpretations is indeed of the same input &quot;aabb&quot;.</span>
    <span class="macro">assert_eq!</span>(<span class="string">&quot;aabb&quot;</span>.<span class="ident">to_string</span>(), <span class="ident">ps</span>.<span class="ident">split_last</span>().<span class="ident">unwrap</span>().<span class="number">1</span>.<span class="ident">iter</span>()
        .<span class="ident">map</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">p</span><span class="op">|</span> <span class="ident">result</span>.<span class="ident">position_info</span>[<span class="ident">p</span> <span class="kw">as</span> <span class="ident">usize</span>].<span class="ident">info</span>.<span class="ident">into_normal</span>().<span class="ident">unwrap</span>())
        .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>());
    <span class="comment">// each position list is chained according to the &#39;follow_pos&#39; relation.</span>
    <span class="ident">ps</span>.<span class="ident">windows</span>(<span class="number">2</span>).<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">p</span><span class="op">|</span>
        <span class="macro">assert!</span>(<span class="ident">result</span>.<span class="ident">position_info</span>[<span class="ident">p</span>[<span class="number">0</span>] <span class="kw">as</span> <span class="ident">usize</span>].<span class="ident">follow_pos</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">p</span>[<span class="number">1</span>])));
});
<span class="comment">// apply a hint to resolve the conflict.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">result</span>;
<span class="kw">match</span> <span class="ident">result</span>.<span class="ident">apply_hint</span>(<span class="string">&quot;aabb&quot;</span>.<span class="ident">chars</span>(), <span class="number">0</span>) {
    <span class="ident">ResolveError::Resolved</span>(<span class="ident">s</span>) =&gt; {
        <span class="comment">// we indeed resolved the conflict between tag &#39;0&#39; and tag &#39;1&#39; for input &quot;aabb&quot;.</span>
        <span class="macro">assert_eq!</span>(<span class="number">2</span>, <span class="ident">s</span>.<span class="ident">len</span>());
        <span class="macro">assert!</span>(<span class="macro">matches!</span>(<span class="ident">result</span>.<span class="ident">position_info</span>[<span class="ident">s</span>[<span class="number">0</span>] <span class="kw">as</span> <span class="ident">usize</span>].<span class="ident">info</span>, <span class="ident">PosInfo::Accept</span>(<span class="number">0</span>)));
        <span class="macro">assert!</span>(<span class="macro">matches!</span>(<span class="ident">result</span>.<span class="ident">position_info</span>[<span class="ident">s</span>[<span class="number">1</span>] <span class="kw">as</span> <span class="ident">usize</span>].<span class="ident">info</span>, <span class="ident">PosInfo::Accept</span>(<span class="number">1</span>)));
    }
    <span class="ident">err</span> =&gt; <span class="macro">panic!</span>(<span class="string">r#&quot;&quot;aabb&quot; should resolve a conflict, but we got {:?} instead&quot;#</span>, <span class="ident">err</span>),
}
<span class="comment">// now we are ready to build the DFA.</span>
<span class="kw">let</span> <span class="ident">resolved</span> <span class="op">=</span> <span class="ident">result</span>.<span class="ident">try_resolve</span>().<span class="ident">expect</span>(<span class="string">&quot;no more conflict expected&quot;</span>);
<span class="comment">// the minimised DFA and the original should behave the same</span>
<span class="kw">for</span> <span class="ident">m</span> <span class="kw">in</span> [<span class="ident">resolved</span>.<span class="ident">clone</span>(), <span class="ident">resolved</span>.<span class="ident">minimise</span>()] {
    <span class="comment">// the following two inputs have no conflict from the very beginning:</span>
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;abb&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap</span>());
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;bbaa&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap</span>());
    <span class="comment">// the hint we used to resolve the conflict behaves well:</span>
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;aabb&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap</span>());
    <span class="comment">// other conflicts are solved just as for the hint:</span>
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;abab&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap</span>());
}</code></pre></div>
<p>The above two example DFAs are actually minimal from the very beginning. Below is an example of
how the DFA can have equivalent states and be properly minimised:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">rowantlr::ir::lexical::Expr</span>;
<span class="kw">let</span> <span class="ident">expr</span> <span class="op">=</span> <span class="ident">Expr::union</span>([
    <span class="ident">Expr::some</span>(<span class="ident">Expr::singleton</span>(<span class="string">&#39;a&#39;</span>)), <span class="comment">// a+</span>
    <span class="ident">Expr::some</span>(<span class="ident">Expr::from</span>(<span class="string">&quot;aa&quot;</span>)),     <span class="comment">// (aa)+</span>
]);
<span class="kw">let</span> <span class="ident">resolved</span> <span class="op">=</span> <span class="ident">expr</span>.<span class="ident">build</span>().<span class="ident">try_resolve</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">minimised</span> <span class="op">=</span> <span class="ident">resolved</span>.<span class="ident">clone</span>().<span class="ident">minimise</span>();
<span class="comment">// the minimised DFA and the original should behave the same</span>
<span class="kw">for</span> <span class="ident">m</span> <span class="kw">in</span> [<span class="kw-2">&amp;</span><span class="ident">resolved</span>, <span class="kw-2">&amp;</span><span class="ident">minimised</span>] {
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(()), <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;a&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap</span>());
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(()), <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;aa&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap</span>());
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(()), <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;aaa&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap</span>());
    <span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">m</span>.<span class="ident">run</span>(<span class="string">&quot;&quot;</span>.<span class="ident">chars</span>()).<span class="ident">unwrap</span>());
}
<span class="macro">assert!</span>(<span class="ident">minimised</span>.<span class="ident">dfa</span>.<span class="ident">state_count</span> <span class="op">&lt;</span> <span class="ident">resolved</span>.<span class="ident">dfa</span>.<span class="ident">state_count</span>);
<span class="macro">assert_eq!</span>(<span class="ident">resolved</span>.<span class="ident">dfa</span>.<span class="ident">state_count</span>, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">minimised</span>.<span class="ident">dfa</span>.<span class="ident">state_count</span>, <span class="number">2</span>);</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BuildResult.html" title="rowantlr::backend::dfa::BuildResult struct">BuildResult</a></div><div class="item-right docblock-short"><p>Result from <a href="struct.Builder.html#method.build"><code>build</code></a>ing a <a href="struct.Dfa.html" title="Dfa"><code>Dfa</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Builder.html" title="rowantlr::backend::dfa::Builder struct">Builder</a></div><div class="item-right docblock-short"><p>Calculate <code>followpos(p)</code> for every position <code>p</code> in a regular expression <code>e</code>.
This piece of information can be used to construct a DFA.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Conflict.html" title="rowantlr::backend::dfa::Conflict struct">Conflict</a></div><div class="item-right docblock-short"><p>Conflict in DFA states.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Dfa.html" title="rowantlr::backend::dfa::Dfa struct">Dfa</a></div><div class="item-right docblock-short"><p>Definite Finite State Automata.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.InvalidInput.html" title="rowantlr::backend::dfa::InvalidInput struct">InvalidInput</a></div><div class="item-right docblock-short"><p>Invalid input for some <a href="struct.Dfa.html" title="Dfa"><code>Dfa</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.NotAcceptState.html" title="rowantlr::backend::dfa::NotAcceptState struct">NotAcceptState</a></div><div class="item-right docblock-short"><p>Decide what to do next for a non-accepting state.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PosEntry.html" title="rowantlr::backend::dfa::PosEntry struct">PosEntry</a></div><div class="item-right docblock-short"><p>Information related to a position in a regular expression.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Reachability.html" title="rowantlr::backend::dfa::Reachability struct">Reachability</a></div><div class="item-right docblock-short"><p>Information for reachability for states in a DFA for a specific <a href="struct.BuildResult.html" title="BuildResult"><code>BuildResult</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Resolved.html" title="rowantlr::backend::dfa::Resolved struct">Resolved</a></div><div class="item-right docblock-short"><p><a href="struct.BuildResult.html" title="BuildResult"><code>BuildResult</code></a> with conflicts resolved.</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ResolveError.html" title="rowantlr::backend::dfa::ResolveError enum">ResolveError</a></div><div class="item-right docblock-short"><p>Result for resolving conflicts.</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="rowantlr" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.59.0 (9d1b2106e 2022-02-23)" ></div>
</body></html>